<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/">
    <channel>
        <title>CNOE Blog</title>
        <link>https://cnoe-io.github.io/blog</link>
        <description>CNOE Blog</description>
        <lastBuildDate>Tue, 04 Jun 2024 00:00:00 GMT</lastBuildDate>
        <docs>https://validator.w3.org/feed/docs/rss2.html</docs>
        <generator>https://github.com/jpmonette/feed</generator>
        <language>en</language>
        <item>
            <title><![CDATA[Argo Workflows Controller Scalability Testing on Amazon EKS]]></title>
            <link>https://cnoe-io.github.io/blog/argo-workflow-scalability</link>
            <guid>argo-workflow-scalability</guid>
            <pubDate>Tue, 04 Jun 2024 00:00:00 GMT</pubDate>
            <description><![CDATA[Introduction]]></description>
            <content:encoded><![CDATA[<h2 class="anchor anchorWithStickyNavbar_LWe7" id="introduction"><strong>Introduction</strong><a class="hash-link" href="#introduction" title="Direct link to heading">​</a></h2><p>In our earlier blog posts, we have discussed scalability tests for Argo CD, where in two consecutive experiments, we pushed the limits of Argo CD to deploy <a href="https://aws.amazon.com/blogs/opensource/argo-cd-application-controller-scalability-testing-on-amazon-eks/" target="_blank" rel="noopener noreferrer">10,000 applications on ~100 clusters</a> and then<a href="https://cnoe.io/blog/argo-cd-application-scalability" target="_blank" rel="noopener noreferrer"> 50,000 applications on 500 clusters</a> along with configuration and fine-tuning required to make Argo CD scale effectively. Argo CD deployments, however, do not happen in isolation, and similar to a <a href="https://cnoe.io/docs/reference-implementation" target="_blank" rel="noopener noreferrer">CNOE stack</a>, Argo CD is often deployed on a cluster along with other tooling which collectively contribute to the performance and scalability bottlenecks we see users run into. </p><p>Argo Workflows is one common tool we often see users deploy alongside Argo CD to enable workflow executions (e.g. building images, running tests, cutting releases, etc). Our early experiments with Argo Workflows revealed that, if not tuned properly, it can negatively impact the scalability of a given Kubernetes cluster, particularly if the Kubernetes cluster happens to be the control cluster managing developer workflows across a large group of users. A real world example of some of the scaling challenges you can encounter with Argo Workflows is explored in our recent ArgoCon talk: <a href="https://www.youtube.com/watch?v=7yVXMCX62tY" target="_blank" rel="noopener noreferrer">Key Takeaways from Scaling Adobe's CI/CD Solution to Support 50K Argo CD Apps</a>.</p><p>For us to better understand the limitations and tuning requirements for Argo Workflows, in this blog post we publish details on the scalability experiments we ran for Argo Workflows executing Workflows in two different load patterns across 50 Amazon EKS nodes. We show the correlation between the various Argo Workflow’s knobs and controls and the processing time as well as performance improvements you can get by determining how you supply the workflows to the control plane.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="test-parameters"><strong>Test Parameters</strong><a class="hash-link" href="#test-parameters" title="Direct link to heading">​</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="test-workflow"><strong>Test Workflow</strong><a class="hash-link" href="#test-workflow" title="Direct link to heading">​</a></h3><p>The test workflow is based on the lightweight whalesay container from docker which prints out some text and ASCII art to the terminal. The reason we chose a lightweight container is that we wanted to stress the Argo Workflows controller in managing the Workflow lifecycle (pod creation, scheduling, and cleanup) and minimize the extra overhead on the Kubernetes control plane in dealing with the data plane workloads. An example of the Workflow is below:</p><div class="language-go codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-go codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token keyword" style="color:#00009f">var</span><span class="token plain"> helloWorldWorkflow </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> wfv1</span><span class="token punctuation" style="color:#393A34">.</span><span class="token plain">Workflow</span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ObjectMeta</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"> metav1</span><span class="token punctuation" style="color:#393A34">.</span><span class="token plain">ObjectMeta</span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        GenerateName</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"> </span><span class="token string" style="color:#e3116c">"hello-world-"</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token punctuation" style="color:#393A34">}</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Spec</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"> wfv1</span><span class="token punctuation" style="color:#393A34">.</span><span class="token plain">WorkflowSpec</span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Entrypoint</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"> </span><span class="token string" style="color:#e3116c">"whalesay"</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ServiceAccountName</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"> </span><span class="token string" style="color:#e3116c">"argo"</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Templates</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">[</span><span class="token punctuation" style="color:#393A34">]</span><span class="token plain">wfv1</span><span class="token punctuation" style="color:#393A34">.</span><span class="token plain">Template</span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            </span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                Name</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"> </span><span class="token string" style="color:#e3116c">"whalesay"</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                Container</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">&amp;</span><span class="token plain">corev1</span><span class="token punctuation" style="color:#393A34">.</span><span class="token plain">Container</span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    Image</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain">   </span><span class="token string" style="color:#e3116c">"docker/whalesay:latest"</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    Command</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">[</span><span class="token punctuation" style="color:#393A34">]</span><span class="token builtin">string</span><span class="token punctuation" style="color:#393A34">{</span><span class="token string" style="color:#e3116c">"cowsay"</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> </span><span class="token string" style="color:#e3116c">"hello world"</span><span class="token punctuation" style="color:#393A34">}</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                </span><span class="token punctuation" style="color:#393A34">}</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            </span><span class="token punctuation" style="color:#393A34">}</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><span class="token punctuation" style="color:#393A34">}</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        PodGC</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">&amp;</span><span class="token plain">wfv1</span><span class="token punctuation" style="color:#393A34">.</span><span class="token plain">PodGC</span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            Strategy</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"> </span><span class="token string" style="color:#e3116c">"OnPodSuccess"</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><span class="token punctuation" style="color:#393A34">}</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token punctuation" style="color:#393A34">}</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token punctuation" style="color:#393A34">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="argo-workflows-settings"><strong>Argo Workflows Settings</strong><a class="hash-link" href="#argo-workflows-settings" title="Direct link to heading">​</a></h3><p>We will be detailing how each of these settings affect Argo Workflow in various experiments later in this blog post.</p><ul><li><p>Controller workers: Argo Workflows controller utilizes different workers for various operations in a Workflow lifecycle. We will be looking at t types of workers for our scalability testing.</p><ul><li><p>workflow-workers (default: 32): These workers are threads in a single Argo Workflows controller that reconcile Argo Workflow Custom Resources (CRs). When a Workflow is created, a workflow-worker will handle the end-to-end operations of the Workflow from ensuring the pod is scheduled to ensuring the pod has finished. The number of workers can be specified by passing the <code>--workflow-workers</code> flag to the controller.</p></li><li><p>pod-cleanup-workers (default: 4): These workers clean up finished Workflows. When a Workflow has finished executing, depending on your clean-up settings, a pod-cleanup-worker will handle cleaning up the pod from the Workflow. The number of workers can be specified by passing the&nbsp;<code>--pod-cleanup-workers</code> flag to the controller.</p></li></ul></li><li><p>Client queries per second (QPS)/Burst QPS settings (default: 20/30):&nbsp;These settings control when the Argo Workflows controller’s Kubernetes (K8s) client starts to throttle requests to the K8S API server. The client QPS setting is for limiting sustained QPS for the k8s client while burst QPS is for allowing a burst request rate in excess of the client QPS for a short period of time. The client QPS/burst QPS can be set by passing the <code>--qps</code> and <code>--burst</code> flag to the controller.</p></li><li><p>Sharding: Sharding with multiple Argo Workflows controllers is possible by running each controller in its own namespace. The controller would only reconcile Workflows submitted in that particular namespace. The namespace of each controller can be specified with the <code>--namespaced</code> flag.</p></li></ul><h2 class="anchor anchorWithStickyNavbar_LWe7" id="key-metrics"><strong>Key Metrics</strong><a class="hash-link" href="#key-metrics" title="Direct link to heading">​</a></h2><p>We chose a set of key metrics for the scalability testing because we wanted to measure how many workflows the Argo Workflows controller can reconcile and process. We will also be looking into K8s control plane metrics which might indicate your control plane cannot keep up with the Argo Workflows workload.&nbsp;</p><ul><li><p>Workqueue depth: The workqueue depth shows workflows which have not been reconciled. If the depth starts to increase, it indicates that the Argo Workflows controller is unable to handle the submission rate of Workflows.</p></li><li><p>Workqueue latency: The workqueue latency is the average time workflows spent waiting in the workqueue. A lower value indicates that the Argo Workflows controller is processing workflows faster so that they are not waiting in the workqueue.</p></li><li><p>K8S api server requests per second: The read and write requests per second being made to the K8S api server.</p></li></ul><p>We didn’t include CPU/Memory as a key metric because during our testing we did not see any significant impacts to both. Most likely because of our simplistic workflows utilized for this benchmark.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="environment">Environment<a class="hash-link" href="#environment" title="Direct link to heading">​</a></h2><p>We ran the experiments in an AWS environment utilizing a single Amazon EKS cluster. The Kubernetes version is 1.27 and Argo Workflows version is 3.5.4. No resource quotas were utilized on the Argo Workflows controller. For the cluster, we will start by provisioning 1x&nbsp;m5.8xlarge Amazon Elastic Compute Cloud (Amazon EC2) instances which will run the Argo Workflows controller and 50x m5.large instances for executing workflows. The number of execution instances is sufficient to run all 5000 workflows in parallel to ensure that pods are not waiting on resources to execute. Monitoring and metrics for Argo Workflows were provided by Prometheus/Grafana.&nbsp;</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="methodology"><strong>Methodology</strong><a class="hash-link" href="#methodology" title="Direct link to heading">​</a></h2><p>There will be two types of load patterns evaluated:</p><p><strong>Increasing Rate Test:</strong> Workflows will be submitted at an increasing rate (workflows/min) until the Argo Workflows controller cannot keep up. The state at which the controller cannot keep up is when there are &gt;0 workflows in the workflow queue or there is increasing queue latency. That rate of Workflow submissions will be noted as the maximum rate at which the Argo Workflows can be processed with the current settings. </p><p><strong>Queued Reconciliation Test:&nbsp;</strong>5000 workflows are submitted in less than minute. Metrics will be monitored from when the Argo Workflows controller starts processing workflows to when it has reconciled all 5000 workflows. The number of nodes is sufficient for running all the workflows simultaneously.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="experiments">Experiments<a class="hash-link" href="#experiments" title="Direct link to heading">​</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="experiment-1-baseline">Experiment 1: Baseline<a class="hash-link" href="#experiment-1-baseline" title="Direct link to heading">​</a></h3><p>In our baseline experiment, we are running in a single Argo Workflows shard (namespace) with default settings.</p><p><strong>Increasing Rate Test:</strong></p><p>As you can see below, the Argo Workflows controller can process up to 270 workflows/min. The average workqueue latency and workqueue depth are nearly zero.  At 300 workflows/min, workqueue latency and workqueue depth starts to increase.</p><p><img loading="lazy" alt="Enter image alt description" src="/assets/images/1-d6f2f88df7f56060c4c8a765a82dcbfb.png" width="974" height="753" class="img_ev3q"></p><p><strong>Queued Reconciliation Test:</strong></p><p>It takes around 17 mins to reconcile 5000 workflows and peak avg workqueue latency was 5.38 minutes.</p><p><img loading="lazy" alt="Enter image alt description" src="/assets/images/2-211e5d9c30190ab7a797043dcdc689e4.png" width="972" height="459" class="img_ev3q"></p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="experiment-2-workflow-workers">Experiment 2: Workflow Workers<a class="hash-link" href="#experiment-2-workflow-workers" title="Direct link to heading">​</a></h3><p>For this experiment, we increase the number of workflow workers from the default of 32 to 128 where the workers use the maximum QPS and burst settings available to them. We also had to increase the number of pod-cleanup-workers to 32 as the Argo Workflows controller was experiencing some instability, where the controller pod was consistently crashing with the default value of 4. </p><p><strong>Increasing Rate Test:</strong></p><p>For the increasing workflow rate test, we can see exactly when the number of workflow workers is not sufficient to process the load. Both workqueue latency and depth start to increase indicating that workflows are waiting to be reconciled. When we increase the number of workers, the controller is able to reconcile the current load until an additional load is placed on it. For 32 workers, that limit is 300 workflows/min. When we increase the number of workers to 64, it is able to process that load until load is increased to 330 workflows/min. Then we increase the number of workers to 96 and it can process the additional load again. When we increase to 360 workflows/min, we need to bump the number of workers to 128.</p><table><thead><tr><th>Workers</th><th>Max workflows/minute</th></tr></thead><tbody><tr><td>32</td><td>270</td></tr><tr><td>64</td><td>300</td></tr><tr><td>96</td><td>330</td></tr><tr><td>128</td><td>360</td></tr></tbody></table><p><img loading="lazy" alt="Enter image alt description" src="/assets/images/3-116cb38fa45fd79d00154959c7823fe9.png" width="971" height="760" class="img_ev3q"></p><p>For the K8S api server, we see sustained 180 writes/sec and 70 reads/sec during the increasing rate tests.</p><p><img loading="lazy" alt="Enter image alt description" src="/assets/images/AYf_Image_1-a76b61333fac9118e74c3538c6bb6ef6.png" width="937" height="787" class="img_ev3q"></p><p><strong>Queued Reconciliation Test:</strong></p><p>For the queued reconciliation test, the time it took to reconcile all the workflows did not change significantly. With 32 workers it took 17 mins to reconcile while with 96 workers it took 16 mins. The peak workqueue latency did decrease from 5.38 mins with 32 workers to 3.19 mins with 96 workers. With 128 workers, the Argo Workflows controller kept crashing.</p><table><thead><tr><th>Workers</th><th>Peak avg latency (mins)</th><th>Reconcile time (mins)</th></tr></thead><tbody><tr><td>32</td><td>5.38</td><td>17</td></tr><tr><td>64</td><td>5.06</td><td>18</td></tr><tr><td>96</td><td>3.19</td><td>16</td></tr><tr><td>128</td><td>N/A</td><td>N/A</td></tr></tbody></table><p><img loading="lazy" alt="Enter image alt description" src="/assets/images/4-c8a05383e3dd19b4f35f4ddf168e9fbb.png" width="971" height="487" class="img_ev3q"></p><p>For the K8S api server, we see peaks of up to 260 writes/sec and 90 reads/sec during the queued reconciliation tests. You notice for the last test that there is no K8S api server activity as the Argo Workflows controller was misbehaving due to client-side throttling.</p><p><img loading="lazy" alt="Enter image alt description" src="/assets/images/ZlY_Image_2-5b7ab12762820f727e0a8b792c505da2.png" width="942" height="795" class="img_ev3q"></p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="observations-from-experiment-2"><strong>Observations from Experiment 2:</strong><a class="hash-link" href="#observations-from-experiment-2" title="Direct link to heading">​</a></h4><p>Workers play a big part in how fast the Argo Workflows controller is able to reconcile the rate of workflows being submitted. If you are observing workflow latency and backing up the workqueue depth, changing the number of workers is a potential way to improve performance. There are a few observations that we want to call out. One is that if we compare the two different patterns, one where we submit workflows at a constant rate and one in which we load up the workqueue all at once, we can see variations in calculated throughput. We can actually calculate the time it takes to reconcile 5000 apps utilizing the increasing rate test results and compare them to the queued reconciliation test.</p><table><thead><tr><th>Workers</th><th>Increasing rate test time to reconciling 5000 workflows (mins)</th><th>Reconcile time of 5000 workflows queued all at once (mins)</th></tr></thead><tbody><tr><td>32</td><td>18.5</td><td>17</td></tr><tr><td>64</td><td>16.6</td><td>18</td></tr><tr><td>96</td><td>15.1</td><td>16</td></tr><tr><td>128</td><td>13.8</td><td>N/A</td></tr></tbody></table><p>We do get some conflicting results when we make this comparison. With 32 and 64 workers, the increasing rate test is actually slower than the queued reconciliation test. But if we increase to 96 workers, we can see that the increasing rate test results are faster. We were unable to compare with 128 workers as the Argo Workflows controller crashed when trying to run the queued reconciliation test. When investigating the cause of the crash, the logs have several messages like the following:</p><div class="language-log codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-log codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">Waited for 6.185558715s due to client-side throttling, not priority and fairness, request: DELETE:https://10.100.0.1:443/api/v1/namespaces/argoworkflows1/pods/hello-world-57cfda8a-dc8b-4854-83a0-05785fb25e4b-3gwthk</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>These messages indicate that we should increase the Client QPS settings which we will evaluate in the next experiment.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="experiment-3-client-qps-settings">Experiment 3: Client QPS Settings<a class="hash-link" href="#experiment-3-client-qps-settings" title="Direct link to heading">​</a></h3><p>For this experiment, we set the number of workflow workers back to the default of 32. We will then increase the QPS/Burst by increments of 10/10, from 20/30 to 50/60. We chose to only increase by 10/10 because any large increase past 50/60 did not yield any performance improvements. We believe that this is partly because we kept the workers at 32.</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="initial-testing"><strong>Initial Testing</strong><a class="hash-link" href="#initial-testing" title="Direct link to heading">​</a></h4><p><strong>Increasing Rate Test:</strong></p><p>The QPS/Burst settings had a significant impact on the increasing rate test. By increasing the QPS/Burst from 20/30 to 30/40, we see ~50% improvement in max workflows/min from 270 to 420. When we increase the QPS/Burst from 30/40 to 40/50, we see another 28% improvement in max workflows/min from 420 to 540. When increasing from 40/50 to 50/60 there was only an additional 5% improvement. For 32 workers, increasing past 50/60 did not yield any significant improvements to the max workflows/min.</p><table><thead><tr><th>QPS/Burst</th><th>Max workflows/minute</th></tr></thead><tbody><tr><td>20/30</td><td>270</td></tr><tr><td>30/40</td><td>420</td></tr><tr><td>40/50</td><td>540</td></tr><tr><td>50/60</td><td>570</td></tr></tbody></table><p><img loading="lazy" alt="Enter image alt description" src="/assets/images/ZgU_Image_3-9ca2e433fea080701af4ce97b19c38b2.png" width="1379" height="1049" class="img_ev3q"></p><p>When changing QPS/Burst, we need to also monitor the K8S API server. Looking at the K8S API server req/s, we see sustained 390 writes/sec and 85 read/sec.</p><p><img loading="lazy" alt="Enter image alt description" src="/assets/images/DNV_Image_4-182669a9a3fd061ba0b23f7f7c0cf017.png" width="939" height="786" class="img_ev3q"></p><p><strong>Queued Reconciliation Test:</strong></p><p>Again, the QPS/Burst settings make a big difference in the queued reconciliation test when compared to just changing the workflow workers. Starting from the default settings of 20/30, we see decreasing reconcile times from 19 mins to 12 mins to 8 mins and finally to 6 mins when setting the QPS/Burst to 50/60. The peak average latency also decreased from 4.79 mins to 1.94 mins. We did note that there was a higher peak avg latency with 30/40 vs 20/30 but if you examine the graph you can see a steeper drop in latency accounting for the shorter reconcile time. Similar to the increasing rate test, increasing the QPS/Burst further did not yield any improvements.</p><table><thead><tr><th>QPS/Burst</th><th>Peak avg latency (mins)</th><th>Reconcile time (mins)</th></tr></thead><tbody><tr><td>20/30</td><td>4.79</td><td>19</td></tr><tr><td>30/40</td><td>5.66</td><td>12</td></tr><tr><td>40/50</td><td>2.98</td><td>8</td></tr><tr><td>50/60</td><td>1.94</td><td>6</td></tr></tbody></table><p><img loading="lazy" alt="Enter image alt description" src="/assets/images/lGk_Image_5-7155dee2d602ff28c6ba4957a700c26a.png" width="1376" height="656" class="img_ev3q"></p><p>When looking at the K8S API server, we see peaks of up to 700 writes/sec and 200 reads/sec during the tests.</p><p><img loading="lazy" alt="Enter image alt description" src="/assets/images/Bpv_Image_6-c62a64840de7c331ae4a926dbe3232c8.png" width="947" height="791" class="img_ev3q"></p><p>When compared to the workflow workers testing, you can see increasing the QPS/Burst is able to push the K8S API server and improve Argo Workflows overall performance. We do see some diminishing returns when increasing QPS/Burst past 50/60 even though it appears that the K8S API server has plenty of capacity for additional load. For the next test, we will increase both the workflow workers with the QPS/burst to see how far we can push Argo Workflows and the K8s API server.</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="max-load-test"><strong>Max Load Test</strong><a class="hash-link" href="#max-load-test" title="Direct link to heading">​</a></h4><p><strong>Increasing Rate Test:</strong></p><p>We increased the number of workers to 128 and QPS/burst to 60/70 and observed peak average latency of 54 secs and a reconciliation time of 5 mins. Increasing either the workers or QPS/Burst did not improve these numbers.</p><p><img loading="lazy" alt="Enter image alt description" src="/assets/images/czp_Image_7-c58e659986c95fa3f0542fc70c6c0bbd.png" width="1520" height="708" class="img_ev3q"></p><p>Looking at the K8s API server, we saw peaks of 800 writes/sec and 190 reads/sec.</p><p><img loading="lazy" alt="Enter image alt description" src="/assets/images/o0Z_Image_8-de223d0852717da7581e45b5b4a3ee6b.png" width="944" height="793" class="img_ev3q"></p><p><strong>Queued Reconciliation Test:</strong></p><p>Starting with 128 workers and QPS/Burst of 60/70, we were able to push Argo Workflows to 810 workflows/min. But past that point, there were no improvements with more workers or increased QPS/Burst limits.</p><p><img loading="lazy" alt="Enter image alt description" src="/assets/images/S1V_Image_9-8517f8a643c7bfaf787f916c9478746e.png" width="1532" height="1052" class="img_ev3q"></p><p>We can see increased K8s API server activity with sustained 700 writes/sec and 160 reads/sec.</p><p><img loading="lazy" alt="Enter image alt description" src="/assets/images/NRO_Image_10-84aacbe750ca5f604e939f2f628bcd8e.png" width="945" height="790" class="img_ev3q"></p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="observations-from-experiment-3"><strong>Observations from Experiment 3</strong><a class="hash-link" href="#observations-from-experiment-3" title="Direct link to heading">​</a></h4><p>One observation we made in the previous experiment with workflow workers is that the two different patterns of submitting workflows can be compared. We made that comparison again with the QPS/Burst tests and saw the following results:</p><table><thead><tr><th>QPS/Burst</th><th>Workers</th><th>Increasing rate test time to reconcile 5000 workflows (mins)</th><th>Reconcile time of 5000 workflows queued all at once (mins)</th></tr></thead><tbody><tr><td>20/30</td><td>32</td><td>18.5</td><td>19</td></tr><tr><td>30/40</td><td>32</td><td>11.9</td><td>12</td></tr><tr><td>50/60</td><td>32</td><td>9.2</td><td>8</td></tr><tr><td>60/70</td><td>32</td><td>8.7</td><td>6</td></tr><tr><td>70/80</td><td>128</td><td>6.1</td><td>5</td></tr></tbody></table><p>When we take the data about the comparison in experiment 1 with the data above, we can see a slight improvement in submitting all workflows together vs staggering them. We are not sure why this is the case and more experiments are required to understand this behavior.</p><p>It seems that we have hit a wall with 128 workers and a QPS/burst of 60/70 for a single Argo Workflows Controller. We will now evaluate Sharding and see if we can improve our performance from this point.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="experiment-4-sharding">Experiment 4: Sharding<a class="hash-link" href="#experiment-4-sharding" title="Direct link to heading">​</a></h3><p>For this experiment, we will evaluate 1 shard, 2 shards, and 5 shards of the Argo Workflows controller with the default settings. We will then try for a maximum load test utilizing workflow workers, QPS/burst, and sharding to see the maximum performance on our current infrastructure.</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="initial-testing-1"><strong>Initial Testing</strong><a class="hash-link" href="#initial-testing-1" title="Direct link to heading">​</a></h4><p><strong>Increasing Rate Test:</strong></p><p>Sharding the Argo Workflows controller has a linear impact on performance with the increasing rate test. By increasing the number of shards from 1 to 2, we see a 100% improvement in max workflows/min from 270 to 540. When we increase the shards from 2 to 5, we see an additional 150% improvement in max workflows/min from 540 to 1350.</p><table><thead><tr><th>Shards</th><th>Max workflows/min</th></tr></thead><tbody><tr><td>1</td><td>270</td></tr><tr><td>2</td><td>540</td></tr><tr><td>5</td><td>1350</td></tr></tbody></table><p>One thing to note is that each shard is increased by 30 workflows/min when increasing the rate. This means that the difference between two rates with 2 shards <em> 30 = 60 workflows/min and the difference between two rates with 5 shards </em> 30 = 150 workflows/min. That is why for 2 shards when the max load was determined at 600 workflows/min, we go down 1 rate which is 600 - 60 = 540 workflows/min.</p><p><img loading="lazy" alt="Enter image alt description" src="/assets/images/WP9_Image_11-d8f7b5848f2adde883ab39b81f4d2cd0.png" width="1532" height="1038" class="img_ev3q"></p><p>You can see a significant impact on the K8s API server with sustained 1400 writes/sec and 300 reads/sec.</p><p><img loading="lazy" alt="Enter image alt description" src="/assets/images/3gj_Image_12-506b3b1f517fda7c68995a3a6eda6c33.png" width="940" height="789" class="img_ev3q"></p><p><strong>Queued Reconciliation Test:</strong></p><p>As shown in the Increasing Rate Test, sharding has a huge impact on performance for the queued reconciliation test. With 1 shard it takes 18 mins to reconcile 5000 workflows, while with 2 shards it takes 9 mins. With 5 shards the reconcile time is further reduced to 4 mins.</p><table><thead><tr><th>Shards</th><th>Peak avg latency (mins)</th><th>Reconcile time (mins)</th></tr></thead><tbody><tr><td>1</td><td>5.43</td><td>18</td></tr><tr><td>2</td><td>3.81</td><td>9</td></tr><tr><td>5</td><td>1.42</td><td>4</td></tr></tbody></table><p><img loading="lazy" alt="Enter image alt description" src="/assets/images/6Bi_Image_13-9f8b7d60ba060017942a0bd9fd4e6d57.png" width="1535" height="699" class="img_ev3q"></p><p>The impact on the K8s API server was not as significant when compared to previous experiments.</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="max-load-test-1"><strong>Max Load Test</strong><a class="hash-link" href="#max-load-test-1" title="Direct link to heading">​</a></h4><p><strong>Increasing Rate Test:</strong></p><p>When increasing the workflow workers to 128, QPS/burst to 60/70 and shards to 5, the Argo Workflows controller is able to process up to 2100 wor</p><p>kflows/min. Any higher than this seems to run into K8s API Priority and Fairness (APF) limits. </p><p><img loading="lazy" alt="Enter image alt description" src="/assets/images/ko7_Image_14-ef2863d49d1ec7088930b86125bf90e3.png" width="1524" height="700" class="img_ev3q"></p><p>When looking at the K8s API server, we are seeing significant impact with peaks of 1500 writes/sec and 350 reads/sec.</p><p><img loading="lazy" alt="Enter image alt description" src="/assets/images/HH7_Image_15-df838398f527e52ea9f83e49c25f7fa3.png" width="936" height="792" class="img_ev3q"></p><p>When investigating why we are unable to push higher on the K8s API server, we see that APF limits are coming into effect by looking at the apiserver_flowcontrol_current_inqueue_requests. This metric shows the number of requests waiting in the APF flowcontrol queue.</p><p><img loading="lazy" alt="Enter image alt description" src="/assets/images/7RZ_Image_16-d969ed38ee1615d676c3dad927c4d2a0.png" width="773" height="329" class="img_ev3q"></p><p><strong>Queued Reconciliation Test:</strong></p><p>With the max load settings, we observed that the peak workqueue latency is only 20 seconds and the reconcile time is 2 minutes.</p><p><img loading="lazy" alt="Enter image alt description" src="/assets/images/F2t_Image_17-b05c04273726be912e3ba7e4685dd3b2.png" width="1513" height="699" class="img_ev3q"></p><p>The impact on K8s API server is actually less than the previous max load queued reconciliation tests.</p><p><img loading="lazy" alt="Enter image alt description" src="/assets/images/05K_Image_18-2d3c1d9b1066c403190c38cd54b423df.png" width="943" height="795" class="img_ev3q"></p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="observations-from-experiment-4"><strong>Observations from Experiment 4</strong><a class="hash-link" href="#observations-from-experiment-4" title="Direct link to heading">​</a></h4><p>As we did in previous experiments, we again make the comparison between the two different load patterns:</p><table><thead><tr><th>Shards</th><th>Increasing rate test time to reconcile 5000 workflows (mins)</th><th>Reconcile time of 5000 workflows queued all at once (mins)</th></tr></thead><tbody><tr><td>1</td><td>18.5</td><td>18</td></tr><tr><td>2</td><td>9.2</td><td>9</td></tr><tr><td>5</td><td>3.7</td><td>4</td></tr><tr><td>Max load (5 shards)</td><td>2.3</td><td>2</td></tr></tbody></table><p>In general, it appears that submitting all workflows at once performs slightly better than submitting workflows at a steady rate. More experiments will need to be done to further investigate this behavior.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="conclusion"><strong>Conclusion</strong><a class="hash-link" href="#conclusion" title="Direct link to heading">​</a></h2><p>In this blog post we discussed our initial efforts in documenting and understanding the scaling characteristics of the Argo Workflows controller. Our findings show that the existing mechanisms for increasing workflow workers, increasing client and burst QPS settings and sharding the controller can help Argo Workflows scale better. Another interesting observation is that we saw differences in performance with how you submit your workflows.  For the next set of experiments, we plan to evaluate more environmental variables and different types of workflows: multi-step and/or long running. Stay tuned for the report on our next round of experiments and reach out on the CNCF <a href="https://cloud-native.slack.com/archives/C04SURUPDL2" target="_blank" rel="noopener noreferrer">#argo-sig-scalability</a> Slack channel to get help optimizing for your use-cases and scenarios.</p>]]></content:encoded>
            <category>workflows</category>
            <category>benchmarking</category>
            <category>scalability</category>
        </item>
        <item>
            <title><![CDATA[Argo CD Benchmarking - Pushing the Limits and Sharding Deep Dive]]></title>
            <link>https://cnoe-io.github.io/blog/argo-cd-application-scalability</link>
            <guid>argo-cd-application-scalability</guid>
            <pubDate>Tue, 21 Nov 2023 00:00:00 GMT</pubDate>
            <description><![CDATA[Introduction]]></description>
            <content:encoded><![CDATA[<h2 class="anchor anchorWithStickyNavbar_LWe7" id="introduction">Introduction<a class="hash-link" href="#introduction" title="Direct link to heading">​</a></h2><p>In <a href="https://aws.amazon.com/blogs/opensource/argo-cd-application-controller-scalability-testing-on-amazon-eks/" target="_blank" rel="noopener noreferrer">Part 1 of our Argo CD benchmarking blog post</a>, we analyzed the impacts of various Argo CD configuration parameters on the performance of Argo CD. In particular we measured the impact of <em>status and operation processes</em>, <em>client QPS, burst QPS</em>, and <em>sharding</em> algorithms on the overall synchronization and reconciliation behavior in Argo CD. We showed that using the right configuration and sharding strategy, particularly by properly setting client and burst QPS, as well as by splitting the workload across multiple workload clusters using Argo CD sharding, overall sync time can be improved by a factor of 4.</p><p>Here, and in Part 2 of our scalability work, we push our scalability experiments for Argo CD further. In particular, among other tests, <em>we run our scalability metrics against a maximum of 500 workload clusters, deploying 50,000 Argo applications</em>. This, to the best of our knowledge, sets the largest scalability testing ever done for Argo CD. We also report on a much deeper set of sharding experiments, utilizing different sharding algorithms for distribution of load across 100 workload clusters. While we report on running our experiments against a legacy sharding algorithm and a round robin algorithm that already exist in <a href="https://github.com/argoproj/argo-cd/releases/tag/v2.8.0" target="_blank" rel="noopener noreferrer">Argo CD 2.8</a>, we also discuss results of workload distribution <em>using 3 new sharding algorithms</em> we developed in collaboration with RedHat, namely: <em>a greedy minimum algorithm</em>, <em>a weighted ring hash algorithm</em>, and <em>a consistent hash with bounded loads algorithm</em>. We show that, depending on the optimization goals one has in mind, choosing from the new sharding algorithms can improve CPU utilization by a factor of 3 and reduce application-to-shard rebalancing by a factor of 5, significantly improving the performance of a highly distributed and massively scaled Argo CD deployment.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="experiment-1-how-client-qpsburst-qps-affects-the-kubernetes-api-server">Experiment 1: How Client QPS/Burst QPS affects the Kubernetes API Server<a class="hash-link" href="#experiment-1-how-client-qpsburst-qps-affects-the-kubernetes-api-server" title="Direct link to heading">​</a></h2><p><strong> <u>Objective:</u> </strong></p><p>The objective of the first experiment is to understand the impact of QPS &amp; Burst Rate parameters on 1/Kubernetes control plane for both the Argo CD cluster and the remote application clusters, and 2/ overall sync duration for Argo CD applications. To understand the impact on Kubernetes API server, we observed following control plane metrics: </p><ul><li>Latency (<code>apiserver_request_duration_seconds_bucket</code>)</li><li>Throughput (<code>apiserver_request_total</code>)</li><li>Error Rate (<code>apiserver_request_total{code=~"[45].."}</code>) for any request
returning an error code 4xx or 5xx.</li></ul><p>To analyze impact on application synchronization, we observed <code>Sync Duration</code> and <code>No. of Goroutines</code> Argo CD server metrics.</p><p><strong> <u>Test Infrastructure:</u> </strong></p><p>In terms of test infrastructure and workload configuration, we had one central Amazon EKS cluster with Argo CD Server running on it. This central cluster connected with three remote Amazon EKS clusters with each one of them hosting 5000 Argo CD applications. Each application is a Configmap (2KB) provisioned in a dedicated namespace. All of the four clusters, one central and three remote, had a dedicated monitoring stack composed of Prometheus and Grafana installed on them.</p><p><strong> <u>Observations:</u> </strong></p><p><strong> Observation 1 - Impact on Argo CD application synchronization </strong></p><p>The table and graphs below highlight the impact of QPS &amp; Burst Rate on “Sync Duration” as well as the average and maximum no. of goroutines active during the test run.</p><table><tbody><tr><td><strong>QPS</strong></td><td><strong>Burst Rate</strong></td><td><strong>Sync Duration</strong></td><td><strong>No. of GoRoutines (Avg)</strong></td><td><strong>No. of GoRoutines (Max)</strong></td></tr><tr><td>50</td><td>100</td><td>61.5 mins</td><td>1760</td><td>1810</td></tr><tr><td>100</td><td>200</td><td>29.5 mins</td><td>2120</td><td>2310</td></tr><tr><td>150</td><td>300</td><td>19.0 mins</td><td>2520</td><td>2760</td></tr><tr><td>200</td><td>400</td><td>18.0 mins</td><td>2620</td><td>2780</td></tr><tr><td>250</td><td>500</td><td>17.5 mins</td><td>2590</td><td>2760</td></tr><tr><td>300</td><td>600</td><td>18.0 mins</td><td>2540</td><td>2760</td></tr></tbody></table><p><img loading="lazy" alt="alt_text" src="/assets/images/image19-2c7a2734a0018e389d2c16791da9493f.png" title="image_tooltip" width="1922" height="635" class="img_ev3q"></p><p>To summarize, during the test, we immediately observed ~52% reduction (from 61.5 mins to 29.5 mins) as we increased QPS &amp; Burst Rate from default values to 100 &amp; 200 respectively. This also correlated with corresponding increase in no. of Goroutines processing application synchronization requests. The benefit from increasing values of these parameters started providing diminishing returns with subsequent runs. Beyond QPS &amp; Burst rate of 150 &amp; 300 respectively, there wasn’t measurable improvement observed. This again correlated with number of Goroutines actively processing sync requests.</p><p><strong> Observation 2 - Impact on central Amazon EKS cluster control plane hosting Argo CD Server </strong></p><p>The table and graphs below highlights the impact of QPS &amp; Burst Rate on throughput and latency from Amazon EKS control plane hosting Argo CD Server. We can observe an increase in request rate per second to the Kubernetes control plane which is in line with previous observations related to increase in no. of goroutines processing the sync requests. The increased activity related to sync operations translates into increased requests to Amazon EKS control plane tapering off at QPS of 150 and Burst Rate of 300. Additional increase in QPS and Burst Rate parameters doesn’t noticeably impact request rate per second.</p><table><tbody><tr><td><strong>QPS</strong></td><td><strong>Burst Rate</strong></td><td><strong>Request Rate (Max)</strong></td><td><strong>Latency p50 (Max)</strong></td><td><strong>Latency p90 (Max)</strong></td></tr><tr><td>50</td><td>100</td><td>27.2 rps</td><td>13.0 ms</td><td>22.6 ms</td></tr><tr><td>100</td><td>200</td><td>31.9 rps</td><td>13.3 ms</td><td>23.1 ms</td></tr><tr><td>150</td><td>300</td><td>39.8 rps</td><td>14.3 ms</td><td>24.0 ms</td></tr><tr><td>200</td><td>400</td><td>41.4 rps</td><td>14.9 ms</td><td>24.4 ms</td></tr><tr><td>250</td><td>500</td><td>39.0 rps</td><td>15.1 ms</td><td>24.4 ms</td></tr><tr><td>300</td><td>600</td><td>40.7 rps</td><td>16.4 ms</td><td>34.5 ms</td></tr></tbody></table><p>From a latency perspective, overall during the course of testing, average (p50) duration remained within range of 13 to 16.5 ms and p90 latency within 22 ms to 34 ms. The error rate remained consistently around ~0.22% with a brief spike to ~0.25% (increase of ~0.03%).</p><p>The relatively low latency numbers and low error rate (<!-- -->&lt;<!-- -->0.25%) indicates that Amazon EKS control plane was able to handle the load comfortably. Increasing QPS and Burst rate only would stretch the control plane to a limited extent indicating it still has resources to process additional requests as long as Argo CD server can generate request traffic.</p><p><img loading="lazy" alt="alt_text" src="/assets/images/image30-3953ec55f6ce3f531ad8325ac8a7e0f1.png" title="image_tooltip" width="1585" height="991" class="img_ev3q"></p><p><strong> Observation 3 - Impact on remote Amazon EKS cluster control plane hosting applications </strong></p><p>We had similar observations regarding latency, throughput and error rate for Amazon EKS control plane of remote application clusters. These are the clusters hosting ~5000 Argo CD applications each and connected to Argo CD Server on the central Amazon EKS cluster. The throughput peaked at ~35 requests per second with QPS and burst rate of 150 &amp; 300 respectively. From an average latency perspective, it remained consistently within single digit millisecond hovering around ~5ms.</p><p><img loading="lazy" alt="alt_text" src="/assets/images/image23-032c5d65156f8d7e03c33abc72423558.png" title="image_tooltip" width="1466" height="987" class="img_ev3q"></p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="experiment-2-revisiting-statusoperation-processors">Experiment 2: Revisiting Status/Operation Processors<a class="hash-link" href="#experiment-2-revisiting-statusoperation-processors" title="Direct link to heading">​</a></h2><p><strong> <u>Objective:</u> </strong></p><p>The objective of the second experiment is to explore why status/operation processors did not have an effect on sync times of our previous experiments. It is possible that the simple nature of ConfigMap applications which takes <!-- -->&lt;<!-- -->1s to deploy is causing this behavior. Most real world applications would consist of tens to hundreds of resources taking longer to be deployed. During this experiment, we will simulate a more complex application which takes longer to deploy than the original ConfigMap application.</p><p><strong> <u>Test Infrastructure:</u> </strong></p><p>Central Argo CD cluster running on a single m5.2xlarge managing 100 application clusters. In order to simulate larger applications, each application will execute a PreSync job which waits 10 seconds before deploying the original ConfigMap application.</p><p>Example of the PreSync Job:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">apiVersion: batch/v1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">kind: Job</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">metadata:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> name: before</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> annotations:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   argocd.argoproj.io/hook: PreSync</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   argocd.argoproj.io/hook-delete-policy: HookSucceeded</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">spec:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> template:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   spec:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     containers:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     - name: sleep</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       image: alpine:latest</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       command: ["sleep", "10"]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     restartPolicy: Never</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> backoffLimit: 0</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p><strong> <u>Observations: </u> </strong></p><p><strong> Observation 1 - Syncing never finishes and require a restart of the application controller to continue syncing </strong></p><p>The screenshot below shows that from the start of the sync test at 17:02 till around 17:41, the sync process was deadlocked. We observed no changes to synced apps and the <code>app_operation_processing_queue</code> was pinned at 10k operations.</p><p><img loading="lazy" alt="alt_text" src="/assets/images/image29-df78f9c31065c80389b873ded0acaf77.png" title="image_tooltip" width="1900" height="1184" class="img_ev3q"></p><p>Looking at the Argo CD console for a single application we see that the PreSync job finished 17 mins ago, but the application stayed in the Syncing phase.</p><p><img loading="lazy" alt="alt_text" src="/assets/images/image25-9c1b4406d66014773f0625dd8fa215ee.png" title="image_tooltip" width="1999" height="512" class="img_ev3q"></p><p><strong> Observation 2: There is a link between client QPS/burst QPS and operation/status processor settings </strong></p><p>In order to fix the sync freezing issue, we increased the client QPS/burst QPS from the default 50/100 to 100/200. After the change we were able to collect data on operation/status processor settings.</p><table><tbody><tr><td>operation/status processors: <strong>25/50</strong><br>Sync time: <strong>45 mins</strong></td><td>operation/status processors: <strong>50/100</strong><br>Sync time: <strong>30 mins</strong></td></tr><tr><td><img loading="lazy" src="/assets/images/image26-372500eaf0b1d82a4184d7a74939e1a9.png" width="330" alt="alt_text" title="image_tooltip" class="img_ev3q"></td><td><img loading="lazy" src="/assets/images/image16-5a03a19b56ba7917d16c0a757edae247.png" width="330" alt="alt_text" title="image_tooltip" class="img_ev3q"></td></tr></tbody></table><p>We can see that there is a link between status/operation processors and client QPS/burst QPS settings. Changing one or the other could be required to improve sync times and Argo CD performance depending on your environment. Our recommendation is to first change the status/operation processor settings. If you run into Argo CD locking up or the performance not increasing further, and you have sufficient resources, you can try increasing the client QPS/burst QPS. But as mentioned in the first experiment, ensure you are monitoring the k8s api-server.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="experiment-3-cluster-scaling">Experiment 3: Cluster Scaling<a class="hash-link" href="#experiment-3-cluster-scaling" title="Direct link to heading">​</a></h2><p><strong> <u>Objective:</u> </strong></p><p>The following experiment is designed to test the compute demands of the Argo CD app controller managing clusters with more than 100 applications.</p><p><strong> <u>Test Infrastructure:</u> </strong></p><p>Central Argo CD cluster with 10 app controller shards running on a single m5.2xlarge node managing 100/250/500 application clusters and 10k 2KB ConfigMap applications.</p><p><strong> <u>Observations:</u> </strong></p><p>From earlier experiences, we can see that when managing 100 clusters, we are close to the limit of a single m5.2xlarge node. As we push further and to 250/500 clusters, we have two observations. The first observation is that the graph data is less smooth than the sync test of 100 clusters. This can indicate that Prometheus is running out of compute as Argo CD is consuming most of it. Please note that we are not using any resource limits/requests in our experiments. If proper resource limits/requests are set, most likely we would only see performance issues with Argo CD and not Prometheus, when operating at the limit of your compute resources. The second observation is that on both the 250/500 cluster tests, there are some drop off in metric data. For the 250 cluster test, there is a blip at the 16:16 mark for Memory Usage. For the 500 cluster test there are blips in data at the 21.05 mark on the Workqueue depth, CPU usage, and Memory usage. In spite of these observations, the sync process completes in a reasonable time.</p><table><tbody><tr><td>Clusters: <strong>100</strong><br>Sync time: <strong>9 mins</strong></td><td>Clusters: <strong>250</strong><br>Sync time: <strong>9 mins</strong></td><td>Clusters: <strong>500</strong><br>Sync time: <strong>11 mins</strong></td></tr><tr><td><img loading="lazy" src="/assets/images/image20-0f667cdd92fa25b49f6c3645151250d4.png" width="220" alt="alt_text" title="image_tooltip" class="img_ev3q"></td><td><img loading="lazy" src="/assets/images/image31-7ef7a9bd738d4ff85ac65f5813a2931f.png" width="220" alt="alt_text" title="image_tooltip" class="img_ev3q"></td><td><img loading="lazy" src="/assets/images/image6-4b0c849b965d3b0c16d3f6d42c77e214.png" width="220" alt="alt_text" title="image_tooltip" class="img_ev3q"></td></tr></tbody></table>From this experiment, you can see that as you approach the limit of your compute resources, Argo CD and other applications running in your k8s environment could experience issues. It is recommended that you set proper resource limits/requests for your monitoring stack to ensure you have insights into what could be causing your performance issues.<h2 class="anchor anchorWithStickyNavbar_LWe7" id="experiment-4-application-scaling">Experiment 4: Application Scaling<a class="hash-link" href="#experiment-4-application-scaling" title="Direct link to heading">​</a></h2><p><strong> <u>Objective:</u> </strong></p><p>This experiment is meant to push the Argo CD app controller beyond 10k applications. As the previous rounds of experiments were performed with 10k apps, the intention of these experiments is to scale the Argo CD app controller up to 50k apps.</p><p><strong> <u>Test Infrastructure:</u> </strong></p><p>We will be performing this experiment on a Central Argo CD cluster with 10 app controller shards and 500 downstream application clusters. As we scale up the applications up to 10k,15k,20k,25k,30k,50k 2KB ConfigMap applications, we will add additional m5.2xlarge node(s) to the Argo CD cluster. </p><p><strong> <u>Observations:</u> </strong></p><table><tbody><tr><td width="33%" valign="top">Sync test at 15k applications with a single m5.2xlarge. You can see blips in data indicating unhealthy behavior on the cluster.</td><td width="33%" valign="top">CPU and Memory Usage is near 100% utilization of 8 vCPUs and 30 GB of memory.</td><td width="33%" valign="top">After adding another node for a total of two m5.2xlarge, we were able to perform a sync in <strong>9 mins</strong>.</td></tr><tr><td valign="top"><img loading="lazy" src="/assets/images/image28-f05b7c6f2cafe65a2ecabc3f549751c6.png" width="220" alt="alt_text" title="image_tooltip" class="img_ev3q"></td><td valign="top"><img loading="lazy" src="/assets/images/image4-c566130260c7093f72cda5f816474e64.png" width="220" alt="alt_text" title="image_tooltip" class="img_ev3q"></td><td valign="top"><img loading="lazy" src="/assets/images/image1-f5f0d2283aa23444889863637678e6e3.png" width="220" alt="alt_text" title="image_tooltip" class="img_ev3q"></td></tr></tbody></table><p>After adding another node, we were able to continue our application scaling tests. You can see in the graphs below that syncing 20k and 25k apps was not a problem. The sync test of 30k apps shown on the third graph shows some blips in data, indicating that we are at the limits of two nodes.</p><table><tbody><tr><td width="33%" valign="top">Apps: <strong>20000</strong><br>Sync time: <strong>12 mins</strong></td><td width="33%" valign="top">Apps: <strong>25000</strong><br>Sync time: <strong>11 mins</strong></td><td width="33%" valign="top">Apps: <strong>30000</strong><br>Sync time: <strong>19 mins</strong></td></tr><tr><td valign="top"><img loading="lazy" src="/assets/images/image18-e86f74e303eff46a63430cee73365634.png" width="220" alt="alt_text" title="image_tooltip" class="img_ev3q"></td><td valign="top"><img loading="lazy" src="/assets/images/image17-43fedeea99d867624b845ad47f5c76cd.png" width="220" alt="alt_text" title="image_tooltip" class="img_ev3q"></td><td valign="top"><img loading="lazy" src="/assets/images/image21-0c13721b7c5fb5c996b6c161ee83d1d6.png" width="220" alt="alt_text" title="image_tooltip" class="img_ev3q"></td></tr></tbody></table><p>For the final test in this experiment, we pushed the cluster to sync 50k apps.</p><table><tbody><tr><td width="33%" valign="top">While the cluster was able to manage reconciliation for the 50k apps as shown by a stable Sync Status graph from 8:40, when we start the sync at the 9:02 mark, you can see unhealthy behavior in the graph data.</td><td width="33%" valign="top">From examining the CPU/Memory Usage, you can see we have 100% CPU utilization across the cluster.</td><td width="33%" valign="top">After scaling the cluster to three m5.2xlarge nodes, we were able to perform a sync in <strong>22 mins</strong>.</td></tr><tr><td valign="top"><img loading="lazy" src="/assets/images/image15-eda9682863d46ffb2dd2b165e603005c.png" width="220" alt="alt_text" title="image_tooltip" class="img_ev3q"></td><td valign="top"><img loading="lazy" src="/assets/images/image11-814de637bf2b49628e2ce057fab69829.png" width="220" alt="alt_text" title="image_tooltip" class="img_ev3q"></td><td valign="top"><img loading="lazy" src="/assets/images/image12-16c9df31942c9777bee5f644a081adcc.png" width="220" alt="alt_text" title="image_tooltip" class="img_ev3q"></td></tr></tbody></table><p>From the scaling tests, we can see that the Argo CD app controller scales effectively by adding compute resources as we increase the number of applications to sync.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="experiment-5-how-many-shards">Experiment 5: How Many Shards?<a class="hash-link" href="#experiment-5-how-many-shards" title="Direct link to heading">​</a></h2><p><strong> <u>Objective:</u> </strong></p><p>In previous experiments, we utilized ten app controller shards running across multiple nodes. In this experiment, we will explore how the number of app controller shards affect performance.</p><p><strong> <u>Test Infrastructure:</u> </strong></p><p>Central Argo CD cluster with 3, 6, 9 app controller shards running on 3 m5.2xlarge node(s) managing 500 application clusters and 50k 2KB ConfigMap applications.</p><p><strong> <u>Observations:</u> </strong></p><p>For the baseline of three shards it took <strong>75 mins</strong> to perform a sync. Adding additional shards saw further improvements with a sync time of <strong>37 mins</strong> for six shards and a sync time of <strong>21 mins</strong> for nine shards. Further increasing shards beyond nine did not yield any improvements.</p><table><tbody><tr><td width="33%" valign="top">Shards: <strong>3</strong><br>Sync time: <strong>75 mins</strong></td><td width="33%" valign="top">Shards: <strong>6</strong><br>Sync time: <strong>37 mins</strong></td><td width="33%" valign="top">Shards: <strong>9</strong><br>Sync time: <strong>21 mins</strong></td></tr><tr><td valign="top"><img loading="lazy" src="/assets/images/image27-1f492fdda9b4cd88e05022ebc284f54c.png" width="220" alt="alt_text" title="image_tooltip" class="img_ev3q"></td><td valign="top"><img loading="lazy" src="/assets/images/image3-210f0699679fc35e094714353e9c27d1.png" width="220" alt="alt_text" title="image_tooltip" class="img_ev3q"></td><td valign="top"><img loading="lazy" src="/assets/images/image8-d97841d73758bb7ca789d40d6989b987.png" width="220" alt="alt_text" title="image_tooltip" class="img_ev3q"></td></tr></tbody></table><p>Looking at the CPU and Memory utilization, you can see that adding shards can improve performance only if there are free resources to consume. With the baseline of three shards, CPU utilization of the nodes are well below eight vCPU that each node is allocated. As we add more shards, we can see CPU utilization increasing until we are close to 100% CPU Utilization with nine shards. Adding any more shards would not yield any performance benefits unless we add more nodes.</p><table><tbody><tr><td width="33%" valign="top">Shards: <strong>3</strong></td><td width="33%" valign="top">Shards: <strong>6</strong></td><td width="33%" valign="top">Shards: <strong>9</strong></td></tr><tr><td valign="top"><img loading="lazy" src="/assets/images/image7-27ca6026145793a93e0fec41b25e319b.png" width="220" alt="alt_text" title="image_tooltip" class="img_ev3q"></td><td valign="top"><img loading="lazy" src="/assets/images/image13-4e80702d5bec96fa51c265181ea66102.png" width="220" alt="alt_text" title="image_tooltip" class="img_ev3q"></td><td valign="top"><img loading="lazy" src="/assets/images/image9-cd07945b45b6f0fea39c9d38cccaf5ad.png" width="220" alt="alt_text" title="image_tooltip" class="img_ev3q"></td></tr></tbody></table><p>From the experiments, the Argo CD app controller sharding mechanism is able to scale as you add more compute resources. Sharding allows both horizontal and vertical scaling. As you add more shards, you can horizontally scale by adding more nodes or vertically scale by utilizing a larger node with more compute resources.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="experiment-6-sharding-deep-dive">Experiment 6: Sharding Deep Dive<a class="hash-link" href="#experiment-6-sharding-deep-dive" title="Direct link to heading">​</a></h2><p><strong> <u>Objective:</u> </strong></p><p>With the release of <a href="https://github.com/argoproj/argo-cd/releases/tag/v2.8.0" target="_blank" rel="noopener noreferrer">Argo CD 2.8</a>, a new sharding algorithm: round-robin was released. The existing legacy sharding algorithm performed a modulo of the number of replicas and the hash sum of the cluster id to determine the shard that should manage the cluster. This led to an imbalance in the number of clusters being managed by each shard. The new round-robin sharding algorithm is supposed to ensure an equal distribution of clusters being managed by each shard. We will also introduce 3 new algorithms: greedy minimum, weighted ring hash, and consistent hash with bounded loads. This experiment will evaluate all the algorithms on shard balance, application distribution and rebalancing on changes to the environment.</p><p><strong> <u>Test Infrastructure:</u> </strong></p><p>Central Argo CD cluster with 10 app controller shards running on 1 m5.2xlarge node managing 100 application clusters and 10k 2KB ConfigMap applications.</p><p><strong> <u>Observations:</u> </strong></p><p>Note: For all the observations, we start monitoring-period when we see items in the operations queue. We end the monitoring-period when all the applications are synced. We then look at the avg metric of CPU/Memory usage during the monitoring-period. </p><p><strong> Legacy </strong> </p><p>The graph below shows the CPU Usage/Memory Usage of the 10 different Argo CD App Controller shards. Looking at the avg, you can see a large variation to how much each shard is utilizing its resources. To make an accurate comparison between the different sharding methods, we calculate <em>the variability</em> by determining the range of the data for both avg CPU usage and Memory usage. The CPU usage variability is calculated by taking the shard with the highest CPU usage and subtracting it from the shard with the least CPU usage: <code>0.55 - 0.23 = 0.32</code>. The Memory usage variability is <code>452 MiB - 225 MiB = 227 MiB</code>.</p><p><strong> Variability: </strong></p><table><tbody><tr><td>CPU:</td><td>0.32</td></tr><tr><td>Memory:</td><td>227 MiB</td></tr></tbody></table><p><img loading="lazy" alt="alt_text" src="/assets/images/image14-25322b8a6a6ba01d8ae187a22978388b.png" title="image_tooltip" width="1896" height="1132" class="img_ev3q"></p><p><strong> Round-Robin </strong></p><p>With the newly introduced Round-Robin algorithm, you can see improved balance across the shards.</p><p><strong> Variability: </strong></p><table><tbody><tr><td>CPU:</td><td>0.02</td></tr><tr><td>Memory:</td><td>110 MiB</td></tr></tbody></table><p><img loading="lazy" alt="alt_text" src="/assets/images/image5-3d36436cb1880370b45d3596f9cb4dd7.png" title="image_tooltip" width="1891" height="1137" class="img_ev3q"></p><p><strong> Better but not perfect </strong></p><p>The new round-robin algorithm does a better job of keeping the number of clusters balanced across the shards. But in a real world environment, you would not have an equal number of applications running on each cluster and the work done by each shard is determined not by the number of clusters, but the number of applications. A new experiment was run which deploys a random number of applications to each cluster with the results below. Even with the round-robin algorithm, you can see some high variability in CPU/Memory usage.</p><p><strong> Variability: </strong></p><table><tbody><tr><td>CPU:</td><td>0.27</td></tr><tr><td>Memory:</td><td>136 MiB</td></tr></tbody></table><p><img loading="lazy" alt="alt_text" src="/assets/images/image24-508c5ce0dc6e0803a16e31fa54b530c0.png" title="image_tooltip" width="1895" height="1134" class="img_ev3q"></p><p><strong> Greedy Minimum Algorithm, sharding by the Number of Apps </strong></p><p>A new algorithm is introduced in order to shard by the number of applications that are running on each cluster. It utilizes a greedy minimum algorithm to always choose the shard with the least number of apps when assigning shards. A description of the algorithm is shown below: </p><p>Iterate through the cluster list:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">1. Determine the number of applications per cluster.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">2. Find the shard with the least number of applications.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">3. Add the number of applications to the assigned shard.</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>The same experiment with a random number of applications running on each cluster is run again with the results shown below. With the new algorithm, there is better balance across the shards.</p><p><strong> Variability: </strong></p><table><tbody><tr><td>CPU:</td><td>0.06</td></tr><tr><td>Memory:</td><td>109 MiB</td></tr></tbody></table><p><img loading="lazy" alt="alt_text" src="/assets/images/image22-7195bed6390399291e7c0c55e647dca6.png" title="image_tooltip" width="1888" height="1128" class="img_ev3q"></p><p>While there is better balance when utilizing the greedy minimum algorithm, there is an issue when changing any aspect of the Argo CD sharding parameters. If you are adding shards, removing shards, adding clusters and/or removing clusters, the algorithm can trigger large scale changes in the shard assignments. Changes to the shard assignments cause shards to waste resources when switching to manage new clusters. This is especially true when utilizing ephemeral clusters in AI/ML training and big data operations where clusters come and go. Starting from the previous experiment from before, we changed the number of shards from 10 to 9 and observed over <strong>75 cluster to shard assignment changes</strong> out of 100 clusters excluding the changes associated with the removed shard. </p><p><strong> Weighted Ring Hash </strong></p><p>In order to decrease the number of shard assignment changes, a well known method called consistent hashing is explored for our use case (<a href="https://www.cs.princeton.edu/courses/archive/fall09/cos518/papers/chash.pdf" target="_blank" rel="noopener noreferrer">Reference</a>). Consistent hashing algorithms utilize a ring hash to determine distribution decisions. This method is already widely utilized by network load balancing applications to evenly distribute traffic in a distributed manner independent of the number of servers/nodes. By utilizing a ring hash algorithm to determine shard assignments, we were able to decrease the number of shard assignment changes when we changed the number of shards from 10 to 9. We observed <strong>48 cluster to shard assignment changes</strong>, excluding the changes associated with the removed shard.</p><p><img loading="lazy" alt="alt_text" src="/assets/images/image10-22b2b37dff8a1b53bed356581ea49fd2.png" title="image_tooltip" width="1906" height="1135" class="img_ev3q"></p><p>To ensure balance, weighting is applied at each shard assignment to ensure the shard with the least number of apps is given the highest weight when choosing shards for assignment. The balancing is not perfect as you can see that CPU variability has increased from the greedy minimum algorithm of 0.06 to 0.12. </p><p><strong> Variability: </strong></p><table><tbody><tr><td>CPU:</td><td>0.12</td></tr><tr><td>Memory:</td><td>163 MiB</td></tr></tbody></table><p><strong> Consistent Hash with Bounded Loads </strong></p><p>The ring hash algorithm was never designed to allow dynamically updating the weights based on load. While we were able to utilize it for this purpose, we looked at another algorithm called Consistent Hashing with Bounded Loads (<a href="https://arxiv.org/abs/1608.01350" target="_blank" rel="noopener noreferrer">Reference</a>) which looks to solve the problem of consistent hashing and load uniformity. By utilizing this new algorithm, we were able to significantly decrease the redistribution of cluster to shard assignments. When we change the number of shards from 10 to 9, we only observed <strong>15 cluster to shard assignment changes</strong> excluding the changes associated with the removed shard.</p><p><img loading="lazy" alt="alt_text" src="/assets/images/image2-24e93b36ede5b0e7ed3b6322f1717013.png" title="image_tooltip" width="1907" height="1135" class="img_ev3q"></p><p>The trade off is slightly worse cluster/app balancing than the weighted ring hash which increased CPU variability from 0.12 to 0.17.</p><p><strong> Variability: </strong></p><table><tbody><tr><td>CPU:</td><td>0.17</td></tr><tr><td>Memory:</td><td>131 MiB</td></tr></tbody></table><p>There are no direct recommendations about which algorithm you should utilize, as each of them have their pros and cons. You should evaluate each for your environment whether you are looking for strict balancing of clusters/apps across the shards or whether you want to minimize the impact of making frequent changes to your Argo CD environment. </p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="conclusion">Conclusion<a class="hash-link" href="#conclusion" title="Direct link to heading">​</a></h2><p>In this blog post, we continued our scalability tests of the Argo CD app controller by answering some questions we had from our first scalability tests about the common scalability parameters. We showed how QPS/Burst QPS affects the k8s api server, determined why status/operation processors did not affect our previous scalability tests, and how those parameters are linked together. We then continued our scalability tests by pushing the Argo CD app controller to 500 clusters and 50,000 apps. We ended our tests by showing that a key component of scaling the Argo CD app controller is how it performs sharding. By doing a deep dive into how the app controller performs sharding we also determined some ways to improve sharding by adding in and evaluating new sharding algorithms. We are currently evaluating how to contribute these changes back to Argo CD. Stay tuned for those contributions and reach out on the CNCF<a href="https://cloud-native.slack.com/archives/C04SURUPDL2" target="_blank" rel="noopener noreferrer"> #argo-sig-scalability</a> or the <a href="https://cloud-native.slack.com/archives/C05TN9WFN5S" target="_blank" rel="noopener noreferrer">#cnoe-interest</a> Slack channel to get help optimizing for your use-cases and scenarios.</p>]]></content:encoded>
            <category>argocd</category>
            <category>benchmarking</category>
            <category>scalability</category>
        </item>
        <item>
            <title><![CDATA[Optimizing for Data Quality in your Developer Portal]]></title>
            <link>https://cnoe-io.github.io/blog/optimizing-data-quality-in-dev-portals</link>
            <guid>optimizing-data-quality-in-dev-portals</guid>
            <pubDate>Wed, 15 Nov 2023 00:00:00 GMT</pubDate>
            <description><![CDATA[Disclaimer: CNOE makes strong assumptions about using a subset of open source technologies when building Internal Developer Platforms (IDPs). Recommendations made and patterns discussed are hence centered around the exact tooling that CNOE adopts to implement a capability within an IDP. In this particular post, we assume Kubernetes as the orchestrator platform, Backstage as the technology that implements the developer portal capability, Argo CD for continuous delivery, and Crossplane or Terraform for infrastructure as code (IaC). Capability and technology names may be used interchangeably in the blog post but practices discussed are primarily around the specific set of technologies named earlier.]]></description>
            <content:encoded><![CDATA[<p><em>Disclaimer: CNOE makes strong assumptions about using a subset of open source technologies when building Internal Developer Platforms (IDPs). Recommendations made and patterns discussed are hence centered around the exact tooling that CNOE adopts to implement a capability within an IDP. In this particular post, we assume Kubernetes as the orchestrator platform, Backstage as the technology that implements the developer portal capability, Argo CD for continuous delivery, and Crossplane or Terraform for infrastructure as code (IaC). Capability and technology names may be used interchangeably in the blog post but practices discussed are primarily around the specific set of technologies named earlier.</em></p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="establishing-the-source-of-truth">Establishing the source of truth<a class="hash-link" href="#establishing-the-source-of-truth" title="Direct link to heading">​</a></h2><p>There are different approaches to representing entities like Kubernetes objects and cloud resources in Backstage. In such context, <em>platform engineers need to optimize for creation of reliable data</em>. The last thing you as a platform provider want to see happen is to lose trust of end users because you are displaying incorrect information. There are however, a number of key decisions to be made when building entity representations in Backstage. Particularly:</p><ol><li>What gets represented in Backstage and what doesn't</li><li>How to ensure the Backstage entity offers an accurate representation of its real world counterpart</li><li>What establishes the source of truth for an entity</li></ol><p>Embracing GitOps practices, the answer to that last question may sound rather trivial: <em>GIT, git is obviously the source of truth, since, you know ... GitOps!</em></p><p>However, while git represents the intended source of truth, truth is actually realized where the resource is deployed, revealing its beloved <em>resource status</em>. That is why you may hear people sarcastically refer to git as the <em>source of hope</em> in GitOps.</p><p>Our current collective of practices reveals that there is no silver bullet when deciding entity representations in a developer portal. What establishes the actual source of truth, from which Backstage entity representations to be drawn, primarily depends on company practices and tools DevOps teams have available to them.</p><p>If you operate a Hub and Spoke model, where a single control plane cluster is responsible for handling platform requirements and separate compute clusters handle the actual workload, the hub cluster could very well become the data source for the Backstage entities. On the other hand, if you operate a federated environment where control plane and data plane workloads are scattered across multiple clusters, Backstage could become the unifier that implements custom entity providers to pull and consolidate data from multiple data sources (i.e. the set of clusters with the right data). In a third approach, the CI may take on the job of hydrating entity definitions with metadata and status information it collects from several data sources, eventually pushing the constructed entity to another repository where it can be observed.</p><p>Next we discuss these approaches in more details.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="use-your-existing-cicd-pipelines-to-construct-the-source-of-truth">Use your existing CI/CD pipelines to construct the source of truth<a class="hash-link" href="#use-your-existing-cicd-pipelines-to-construct-the-source-of-truth" title="Direct link to heading">​</a></h2><p>Starting from the specification of entities and infrastructure resources in a
git repository, this approach utilizes tasks in the CI to hydrate entities with
information on entity relations, extra metadata, and status of deployed
resources. To avoid conflating user changes and automated CI changes, the
hydrated entities are often kept in a separate git repository that mirrors and
expands entities in the original git repository with intended application
specifications.</p><p>On the positive side:</p><ul><li>This is a relatively simple approach and works for smaller teams with smaller number of applications or systems</li><li>Having a second git repository to capture the end state of an entity stays closer to the core GitOps practices</li><li>Does not require significant modification to the developer portal</li></ul><p>On the negative side:</p><ul><li>There is inherent duplications that are happening</li><li>Adding custom metadata by application teams is not as trivial as it requires making changes to the integration workflow, thus bringing load and demand to the DevOps teams</li><li>Less abstraction in place as end application users are directly exposed to the yaml specification of the entities</li><li>Does not scale well as the number of systems and entities grow</li></ul><p><img loading="lazy" alt="ci-as-source-of-truth" src="/assets/images/ci-as-sot-aab3827d5d0bf81df84c59e6f703b5c1.png" width="1904" height="848" class="img_ev3q"></p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="use-a-central-control-plane-as-the-source-of-truth">Use a central control plane as the source of truth<a class="hash-link" href="#use-a-central-control-plane-as-the-source-of-truth" title="Direct link to heading">​</a></h2><p>The hub and spoke model is the most advocated for model when applying GitOps practices. Your control plane cluster runs and manages your platform tools, your CI, your CD, developer portal, infrastructure as code tooling, etc.</p><p>On the positive side:</p><ul><li>There really is a single place to inspect the status of entities. E.g., Argo applications can tell you the status of deployed applications. You can also inspect the status of workflows, infrastructure resources, and any other entity that the control plane cluster manages.</li><li>You can use the Backstage Kubernetes plugin seamlessly and maybe with some little tweaks. Alternatively this can be achieved by introducing fairly light-weight Backstage custom entity providers which pull and show the status of entities in the Backstage portal.</li><li>In an organization with a diverse set of distributed systems, the control plane cluster can be used as the integration layer by wrapping legacy APIs and or implementing native controllers.</li></ul><p>On the negative side:</p><ul><li>Most organizations do not have a central control plane and adopting one as the source of truth is often a significant change, especially if an organization is early in their GitOps transition.</li><li>For organizations deep into a federated model of operation with different teams running and managing their platforms separately and rather independently, it could be challenging to offer a single control plane that aggregates data across all teams.</li><li>Management of change could become cumbersome. Existence of a single control plane could create bottlenecks where changes occur to a set of entities or practices. Changes in organizations or systems may result in changes to various entities managed across several teams. Bringing GitOps practices to the mix, this requires chains of approvals to happen across multiple entities and across several repositories for deployments to start flowing. Depending on the size of the organization, this could lead to organizational nightmares.</li><li>You may need to jump through a few hoops before getting from the representation of the application, to the actual deployment of it, e.g., going from git to your continuous delivery and from there to your target cluster.</li></ul><p><img loading="lazy" alt="controlplane-as-source-of-truth" src="/assets/images/cp-as-sot-3f037de15fbbdfc86df959d57029b7d3.png" width="2578" height="1146" class="img_ev3q"></p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="use-backstage-as-the-source-of-truth">Use Backstage as the source of truth<a class="hash-link" href="#use-backstage-as-the-source-of-truth" title="Direct link to heading">​</a></h2><p>Where control planes and compute workloads are scattered, the unifying layer lies in the developer portal, i.e. Backstage. Hence, it is reasonable to construct an entity by collecting and aggregating data from various data sources, each providing partial data on the entity, making Backstage be the source of truth. This generally starts with Backstage querying git for the entities that exist. Then using the identifiers for the entities to collect metadata on how the entity contributes to a system. This could involve querying the control plane clusters and the workload clusters via some custom entity provider that looks for certain information and putting collected pieces together to come close to the core promise of a developer portal, <em>providing reliable information</em> on the entities.</p><p>On the positive side:</p><ul><li>This model copes better with legacy systems</li><li>Users are not exposed to and often times not even aware of the underlying platforms, hence underlying platform and tooling is more rigorously abstracted away</li><li>Changes to the system are only isolated to the entities of the particular system as managed by the underlying resources and platform. This causes less chaos when definitions, metadata, or properties of entities need to change.</li></ul><p>On the negative side:</p><ul><li>The git service may not be able to scale, technically or financially.  This is particularly because Backstage may hit the git service endpoints too frequently and exceed the API limits. This could cause delays in displaying data for end users or display wrong information if partially available data is mishandled. This can be mitigated via approaches like using an eventing mechanism to notify Backstage of changes, or alternatively to store entity definitions in an alternative storage space (e.g. Amazon S3). There are challenges to such approaches too, for example when using Amazon S3, change history will be lost. Also, using an eventing mechanism could introduce security challenges that we discuss next.</li><li>Securing Backstage could be a challenge. For Backstage to proactively receive updates on entity changes, it would work best to configure event hooks to provide callbacks to Backstage when changes occur. Backstage, being the entry point for user workflows, sits on the critical path of platform operations. As such, platform engineers need to solve for a chicken and egg problem by deciding how to expose Backstage endpoints to receive events and yet to limit access for security reasons. The authentication methods that GitHub supports may not satisfy the security standards that an organization requires.</li><li>Changes to entities may not be as trivial. DevOps engineers need to manage entities that they may not control. For example, if a new mandatory field is introduced to a catalog file, DevOps engineers may need to talk to the respective repository owners, create a PR, then get approval for all affected repositories.</li></ul><p><img loading="lazy" alt="backstage-as-source-of-truth" src="/assets/images/bg-as-sot-aa6d086d3fe6ab09d3e266c149266c76.png" width="2342" height="984" class="img_ev3q"></p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="conclusion">Conclusion<a class="hash-link" href="#conclusion" title="Direct link to heading">​</a></h2><p>We discussed multiple approaches to creating reliable representation of system entities in the developer portals. We do not necessarily recommend one approach over another, but it is important to find the right approach given the patterns and practices in your organization. It is also worth noting that you can choose to combine multiple approaches depending on the requirements of your teams. For example, while continuous integration can still be used to construct the actual state of the world by collecting status data and other related information, Backstage extensions can be introduced to expand on entity relations, providing better representation of a system. Stating the obvious here, but your proper selection of patterns that work for you will go a long way in increasing your overall team velocity down the road.</p><p>Reach out on <a href="https://cloud-native.slack.com/archives/C05TN9WFN5S" target="_blank" rel="noopener noreferrer">#cnoe-interest</a> CNCF slack channel to share thoughts and get involved in developing CNOE.</p>]]></content:encoded>
            <category>backstage</category>
            <category>dev portal</category>
            <category>data ingestion</category>
        </item>
        <item>
            <title><![CDATA[CNOE - A Joint Effort to Share Internal Developer Platform Tools and Best Practices.]]></title>
            <link>https://cnoe-io.github.io/blog/welcome</link>
            <guid>welcome</guid>
            <pubDate>Tue, 03 Oct 2023 00:00:00 GMT</pubDate>
            <description><![CDATA[Adobe, Amazon Web Services, Autodesk, Salesforce, and Twilio have come together to launch an open source initiative for building internal developer platforms (IDPs). Cloud Native Operational Excellence (aka, CNOE, pronounced Kuh.no) is a joint effort to share developer tooling, thoughts, and patterns to help organizations make informed technology choices and resolve common pain points. CNOE will enable organizations to navigate tooling sprawl and technology churn by coordinating contributions, offering tools, and providing neutral and unbiased guidance on technology choices to deliver internal developer platforms.]]></description>
            <content:encoded><![CDATA[<p>Adobe, Amazon Web Services, Autodesk, Salesforce, and Twilio have come together to launch an open source initiative for building internal developer platforms (IDPs). Cloud Native Operational Excellence (aka, CNOE, pronounced Kuh.no) is a joint effort to share developer tooling, thoughts, and patterns to help organizations make informed technology choices and resolve common pain points. CNOE will enable organizations to navigate tooling sprawl and technology churn by coordinating contributions, offering tools, and providing neutral and unbiased guidance on technology choices to deliver internal developer platforms.  </p><p>Developer productivity is increasingly important for organizations to compete in today’s fast-paced marketplace. To increase productivity, many organizations are taking a platform engineering approach to build internal developer platforms that abstract away complexity and enable faster, more secure software delivery. These internal developer platforms are long-term strategic investments, and the choice of open source technologies and architectures used to build these platforms can greatly impact their long-term success and viability. </p><p>CNOE is a community for organizations passionate about evolving experiences in developer productivity and efficiency. Contributors to this community are sharing their open source developer platform tooling choices to bring awareness to the best practices that have helped their respective teams. With such awareness comes alignment and the ability to de-risk their technology choices over the long term. </p><p>The CNOE community will navigate their operational technology decisions together, coordinate contributions, and offer guidance on which Cloud Native Computing Foundation (CNCF) technologies to use to achieve cloud efficiencies. CNOE will aim to: </p><p>Create an open source first strategy for internal developer platform capabilities, prioritizing CNCF technologies. </p><p>Build community alignment on technology choices and best practices. </p><p>Elevate tools and practices that can benefit a wide range of organizations building their own internal developer platforms. </p><p>Build for the infrastructure and customize to developer needs, making the solutions and patterns flexible for adoption. </p><p>Provide artifacts about tools, patterns, and practices to be easily consumable by the community.   </p><p>“The work of building secure, reliable, compliant, and regionalized software is becoming more and more complicated. Development teams need the right separation of concerns to build efficiently and move fast. Internal developer platforms enable just that. They abstract away complexity so a team can focus fully on their key goals. I’m excited to see the CNOE community share experiences, expand ideas beyond a single company’s viewpoint, and de-risk our technology strategies to build better together.” - Ben Cochran, VP Developer Enablement at Autodesk </p><p>"As a technology company, CNOE is an extension of our DNA, and open source is key to our platform. CNOE fosters collaboration within the industry, minimizes duplicated work, and emphasizes unique products. I'm eager to see our contributions to CNOE and others benefiting from it." - Chris Lyon, VP of Engineering Segment at Twilio. </p><p>"Open source software is a core component that many organizations leverage to power their internal developer platforms. Organizations often anchor on specific capabilities to power their developer platforms like Continuous Integration/Continuous Delivery, Infrastructure as Code, Service Mesh, Policy controls, Artifact management, and developer portals. As a result, they have been seeking a forum to share best practices and to share their findings on the tooling choices they have been using. I’m incredibly excited to see AWS contribute to CNOE and CNOE be the vehicle that creates industry alignment based on the intrinsic gravity of the tooling choices being made at scale.” - said Paul Roberts, Sr. Principal Solutions Architect at AWS. </p><p>“Adobe believes in the transformative power of open source software.  We are excited to be a founding member of CNOE and to partner with other industry thought leaders to define and share our vision of a cloud native stack for rapidly building Internal Developer Platforms.” - Dave Weinstein, VP of Engineering at Adobe. </p><p>“Salesforce is deeply engaged in the Open Source community, which was integral in building Hyperforce, a reimagination of our trusted platform architecture for the public cloud. Salesforce is honored to serve as a launch partner for CNOE, further advancing the adoption of open source technologies and assuring companies of sound technology decisions and sustained support for years to come.” - Josh Meier, Hyperforce Lead Architect </p><p>With the launch of CNOE, members will contribute tooling, plugins, and reference implementations that facilitate building internal developer platforms. Members are also releasing a capability map that captures key open technologies and their relevance in building internal developer platforms across these organizations. </p><p>As we move forward, each member organization will continue to share their approach on adopting and composing the tooling and technologies recommended by the CNOE working group to deliver on their IDPs.  </p><p>CNOE invites more companies to join us. To learn more about CNOE, visit <a href="https://cnoe.io" target="_blank" rel="noopener noreferrer">https://cnoe.io</a>, where we share extended details about patterns and practices we are developing. Explore options to get involved and contact us via the CNCF slack channel <a href="https://cloud-native.slack.com/archives/C05TN9WFN5S" target="_blank" rel="noopener noreferrer">#cnoe-public</a>.</p><p><em>Special thanks to the many people who helped with the launch, Andrew Lee, Omar Kahil, Ben Fields, Bryan Landes, Vikram Venkataraman, Rick Sostheim, Manabu McCloskey, Praseeda Sathaye, and Vara Bonthu from AWS, Rob Hilton (formerly AWS, now Google), Jesse Sanford, Greg Haynes, Mani Kandadai Venkatesh, Sara Mesing, and Brandon Leach from Autodesk, Jesse Adametz and Wes Medford from Twilio, Rohan Kapoor and Vikram Sethi from Adobe.</em></p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="member-announcements">Member Announcements<a class="hash-link" href="#member-announcements" title="Direct link to heading">​</a></h3><ul><li>Announcement on the <a href="https://aws.amazon.com/blogs/opensource/cloud-native-operational-excellence-cnoe-a-joint-effort-to-share-internal-developer-platform-tools-and-best-practices" target="_blank" rel="noopener noreferrer">AWS Website</a></li><li>Announcement on the <a href="https://forums.autodesk.com/t5/engineering-hub-blog/cloud-native-operational-excellence-cnoe-a-joint-effort-to-share/ba-p/12282822" target="_blank" rel="noopener noreferrer">Autodesk
Website</a></li></ul>]]></content:encoded>
            <category>launch</category>
            <category>hello</category>
            <category>cnoe</category>
        </item>
    </channel>
</rss>