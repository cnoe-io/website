"use strict";(self.webpackChunkcnoe=self.webpackChunkcnoe||[]).push([[5160],{8453:(e,t,n)=>{n.d(t,{R:()=>a,x:()=>o});var s=n(6540);const i={},r=s.createContext(i);function a(e){const t=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),s.createElement(r.Provider,{value:t},e.children)}},8917:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>o,default:()=>d,frontMatter:()=>a,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"reference-implementation/idp-ref/access-management","title":"Access Management","description":"utilizing CNOE for Access Management","source":"@site/docs/reference-implementation/idp-ref/access-management.md","sourceDirName":"reference-implementation/idp-ref","slug":"/reference-implementation/idp-ref/access-management","permalink":"/docs/reference-implementation/idp-ref/access-management","draft":false,"unlisted":false,"editUrl":"https://github.com/cnoe-io/website/tree/main/docs/reference-implementation/idp-ref/access-management.md","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"sidebar_position":1,"description":"utilizing CNOE for Access Management","title":"Access Management"},"sidebar":"tutorialSidebar","previous":{"title":"Set up IDP Reference Implementation on Local Machine","permalink":"/docs/reference-implementation/idp-ref/"},"next":{"title":"Infrastructure Control Plane","permalink":"/docs/reference-implementation/idp-ref/control-plane"}}');var i=n(4848),r=n(8453);const a={sidebar_position:1,description:"utilizing CNOE for Access Management",title:"Access Management"},o=void 0,c={},l=[{value:"Keycloak",id:"keycloak",level:2},{value:"Backstage and Kubernetes Authentication",id:"backstage-and-kubernetes-authentication",level:2}];function u(e){const t={a:"a",h2:"h2",p:"p",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.h2,{id:"keycloak",children:"Keycloak"}),"\n",(0,i.jsxs)(t.p,{children:["In the implementation, ",(0,i.jsx)(t.a,{href:"https://www.keycloak.org/",children:"Keycloak"})," is used as the identity provider. This instance is used to login into UIs such as Backstage and Argo."]}),"\n",(0,i.jsxs)(t.p,{children:["Although it is not configured to be a identity broker or a user federation provider, you can configured it to be one. For example, you can configure it to federate users from Active Directory.\nKeycloak supports a large number of identity providers to integrate with. Please refer to ",(0,i.jsx)(t.a,{href:"https://www.keycloak.org/docs/latest/server_admin/",children:"the documentation"})," for more information."]}),"\n",(0,i.jsx)(t.h2,{id:"backstage-and-kubernetes-authentication",children:"Backstage and Kubernetes Authentication"}),"\n",(0,i.jsxs)(t.p,{children:["In the reference implementation, it uses the server side authentication pattern. ",(0,i.jsx)(t.a,{href:"https://backstage.io/docs/features/kubernetes/authentication",children:"Server side authentication"})," is the pattern that all users on Backstage share the same credential and access level when accessing resources in the cluster. For example, for accessing secret resources, the same service account token is used for a configured Kubernetes cluster regardless of the user requesting resources. This is not ideal for use cases where a Backstage instance is shared by multiple teams. For example, when tying infrastructure and application provisioning to Backstage, it is important to ensure only authorized persons can access certain actions. For example, only admins should be able to delete a Kubernetes cluster in AWS."]}),"\n",(0,i.jsxs)(t.p,{children:["Backstage has the ability to enforce policies through the ",(0,i.jsx)(t.a,{href:"https://backstage.io/docs/permissions/overview",children:"Permission Framework "})," about who can invoke what API actions. Although it is not enabled for the implementation currently, we would like to enable this in the future.\nExpanding on Backstage's permissions framework, examples provided in the documentation requires writing policies in TypeScript, and they need to be pulled into the Backstage application code. From the Kubernetes centric platform perspective, it makes a lof of sense to leverage policy engines like Kyverno or OPA Gatekeeper if possible."]}),"\n",(0,i.jsxs)(t.p,{children:["Client side authentication can be more fine tuned. ",(0,i.jsx)(t.a,{href:"https://backstage.io/docs/features/kubernetes/authentication#client-side-providers",children:"Client side authentication"})," means actions are performed using the user's credentials. This means even if a cluster is listed and configured for use in Backstage, as long as the logged in user does not have permissions for the cluster, performing actions on the cluster is denied. Currently this is not natively supported by Backstage for EKS clusters. This requires more complex configuration and support from Backstage frontend plugin to properly pass user credentials to the cluster through the Kubernetes proxy in Backstage backend."]})]})}function d(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(u,{...e})}):u(e)}}}]);